#include <stdio.h>
#include <inttypes.h>

uint64_t repdigits[] = {0, 1, 11, 111, 1111, 11111, 111111, 1111111, 11111111, 111111111, 1111111111};

#define ONES_DIGITS (uint64_t[]){1, 3, 7, 9}
#define ONES_DIGITS_C 4
#define DMR_PRIMES (uint64_t[]){2, 13, 23, 1662803}
#define DMR_PRIMES_C 4
#define N 10

uint64_t powmod(unsigned __int128 b, uint64_t e, uint64_t n){
	unsigned __int128 r = 1;
	b %= n;
	while(e){
		if(e&1){
			r = r*b%n;
		}
		e >>= 1;
		b = b*b%n;
	}
	return (uint64_t)r;
}

int isPrime(uint64_t n){
	uint64_t s, d;//s, d | 2^s*d = n - 1
	if(n%2 == 0){
		return n == 2;
	}
	--n;
	s = __builtin_ctz(n);
	d = n>>s;
	++n;
	for(uint64_t i = 0, a, x; i < DMR_PRIMES_C; ++i){
		a = DMR_PRIMES[i];
		if(a >= n){
			break;
		}
		x = powmod(a, d, n);
		if(x == 1 || x == n - 1){
			goto CONTINUE_WITNESSLOOP;
		}
		for(a = 0; a < s - 1; ++a){
			x = powmod(x, 2, n);
			if(x == 1){
				return 0;
			}
			if(x == n - 1){
				goto CONTINUE_WITNESSLOOP;
			}
		}
		return 0;
		CONTINUE_WITNESSLOOP:;
	}
	return 1;
}

/* @param l the number of digits left to fill
 * @param n the number of digits left that must be equal to the repeated digit (should not be 0 on first call (b = 0, p = 1))
 * @param d the repeated digit
 * @param b the base part of the number computed in prior recursion (first call b = 0)
 * @param p the power of ten to multiply the number generated by before adding it to b to get the full number (first call p = 1)
 * I LOVE RECURSION AND I CANNOT LIE!
 * @return the sum of all prime numbers formed by adding l digits, n of which are d, to the front of the number b
 */
uint64_t sumPrimesnd(int l, int n, int d, uint64_t b, uint64_t p){
	if(n < 0){//too many digits have been set to d in the invocation of sumPrimesnd that called this, return 0
		return 0;
	}
	if(n == l){//every remaining digit must be d, so make it so and return (this is the real base case)
		if(!d && l){//d == 0 cannot be the leading digit
			return 0;
		}
		b += d*repdigits[l]*p;
		return isPrime(b)?b:0;
	}
	uint64_t s = 0;
	if(p == 1){//special case, first (one's) digit.  Can be 1, 3, 7, or 9.  2 and 5 would work for 1 digit numbers, but those are never generated by this program
		for(int i = 0; i < ONES_DIGITS_C; ++i){
			b = ONES_DIGITS[i];
			s += sumPrimesnd(l - 1, (b == d)?n - 1:n, d, b, p*10);//Ill advised ternary operator
		}
		return s;
	}
	for(int i = (l == 1)?1:0; i < 10; ++i){
		s += sumPrimesnd(l - 1, (i == d)?n - 1:n, d, i*p + b, p*10);
	}
	return s;
}

int main(void){
	uint64_t s = 0, ss;
	for(int d = 0, n; d < 10; ++d){
		n = d?N - 1:N - 2;//subtract 2 if d is 0 because neither the first nor last can be 0
		while(n){
			if((ss = sumPrimesnd(N, n, d, 0, 1))){
				break;
			}
			--n;
		}
		if(!ss){
			puts("n reached 0 somehow");
			return 1;
		}
		//printf("S(%i, %i) = %"PRIu64"\n", N, d, ss);
		s += ss;
	}
	printf("%"PRIu64"\n", s);
}

