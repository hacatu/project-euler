from math import log

repdigits = [0, 1, 11, 111, 1111, 11111, 111111, 1111111, 11111111, 111111111, 1111111111]
onesDigits = [1, 3, 7, 9]
dmrPrimes = [2, 13, 23, 1662803]
N = 10

def __builtin_ctz(n):
	n &= -n
	return int(log(n, 2))

def isPrime(n):
	def witness(x, n, s):
		if x == 1 or x == n - 1:
			return 1
		for a in range(0, s - 1):
			x = x*x%n
			if x == 1:
				return 0
			if x == n - 1:
				return 1
		return 0
	if n%2 == 0:
		return n == 2
	n -= 1
	s = __builtin_ctz(n)
	d = n>>s
	n += 1
	for a in dmrPrimes:
		if a >= n:
			break
		x = pow(a, d, n)
		if not witness(x, n, s):
			return 0
	return 1;

"""@param l the number of digits left to fill
 * @param n the number of digits left that must be equal to the repeated digit (should not be 0 on first call (b = 0, p = 1))
 * @param d the repeated digit
 * @param b the base part of the number computed in prior recursion (first call b = 0)
 * @param p the power of ten to multiply the number generated by before adding it to b to get the full number (first call p = 1)
 * I LOVE RECURSION AND I CANNOT LIE!
 * @return the sum of all prime numbers formed by adding l digits, n of which are d, to the front of the number b
"""
def sumPrimesnd(l, n, d, b, p):
	if n < 0:#too many digits have been set to d in the invocation of sumPrimesnd that called this, return 0
		return 0
	if n == l:#every remaining digit must be d, so make it so and return (this is the real base case)
		if d == 0 and l != 0:#d == 0 cannot be the leading digit
			return 0
		b += d*repdigits[l]*p
		return b if isPrime(b) else 0
	s = 0
	if p == 1:#special case, first (one's) digit.  Can be 1, 3, 7, or 9.  2 and 5 would work for 1 digit numbers, but those are never generated by this program
		for b in onesDigits:
			s += sumPrimesnd(l - 1, n - 1 if (b == d) else n, d, b, p*10)#Ill advised ternary operator
		return s
	for i in range(1 if (l == 1) else 0, 10):
		s += sumPrimesnd(l - 1, n - 1 if (i == d) else n, d, i*p + b, p*10)
	return s

s = 0
for d in range(0, 10):
	n = N - 2 if d == 0 else N - 1#subtract 2 if d is 0 because neither the first nor last can be 0
	while n:
		ss = sumPrimesnd(N, n, d, 0, 1)
		if ss != 0:
			break
		n -= 1
	if ss == 0:
		print("n reached 0 somehow")
	else:
		print("S({0}, {1}) = {2}".format(N, d, ss))
		s += ss
print(s)

